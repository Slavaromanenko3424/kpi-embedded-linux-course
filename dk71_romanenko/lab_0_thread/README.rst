=================================================
**Лабораторна робота №0 Робота з потоками**
=================================================


**Завдання:**
~~~~~~~~~~~~~
Написати код в якому:

* Створити глобальну змінну та ініціалізувати її нулем;
* Створити функцію потоку,яка N разів додає до цієї змінної К - (в моєму випадку це 1);
* Запустити два потоки з цією функцією;
* Дочекатись завершення потоків використовуючи ``pthread_join()`` ;
* Вивести в ``stdout`` очікуване та фактичне значення глобальної змінної;

**Хід роботи:**
---------------
Для полегшення написання та відладки коду спочатку було вирішено створити MakeFile з рецептами для компіляції проекту та чистки артефактів

Особливістю написаного MakeFile є:

* змінна OPTFLAG (флаг оптимізації) - її ми можемо змінювати при запуску MakeFile. Це дозволить нам протестувати програму при різниї оптимізаціях;


Написаний код знаходиться в директорії ``src`` під назвою ``thread.c``.

Для роботи з потоками використовуємо біблотеку - ``pthread.h``
Для полегшення створимо константу, яка буде відповідати кількості потоків ``NUM_OF_THREADS``.

Ітерувати в потоці будемо змінну - ``global_var`` типу ``long``. Функція для ітерації має назву - ``counting_thread``. Її ми будемо викликати в 
двох потоках. Код цієї функції:

.. code-block:: C

  void *counting_thread(void *args)
{
	int steps = *((int *)args); 
	
	for(int i = 0; i < steps; i++) {
		global_var++;	
	} 
}

В функція ``main`` є дві змінні:

* ``steps`` - її ми ініціалізуємо аргументом командного рядку. Ця змінна використовується для визначення к-ті ітерацій.

За допомогою функції ``pthread_create`` створються потоки
А функція ``pthread_join`` очікує їх завершення. Лістинг функції:

.. code-block:: C

int main(int argc, char *argv[])
{
	if(argc != NUM_OF_THREADS) {
		perror ("WTF!WHERE THIS THEREADS");		
	    	exit (EXIT_FAILURE);
	}
	
	long steps;
	assert (1 == sscanf(argv[1], "%ld", &steps));
	
	pthread_t *threads = calloc(NUM_OF_THREADS, sizeof(*threads));
	
	for (long i = 0; i < NUM_OF_THREADS; i++){
		assert (!pthread_create(&threads[i], NULL, &counting_thread, &steps));
	}
	
	for (long i = 0; i < NUM_OF_THREADS; i++){
		pthread_join(threads[i], NULL);
	}
	
	long later_thread = global_var;
	
	global_var = 0;			
	
	for(long i = 0; i < NUM_OF_THREADS; i++) {
		counting_thread(&steps);
	}
	
	printf("Expected: %ld, got: %ld, it is - %s\n", global_var, later_thread, (global_var == later_thread ? "OK" : "FAIL"));
	
	return 0;
}
.. table:: Отримані результати

   +----------------------------------------------------------------------------------------------------+
   |                                      Результати                                                    |
   +------------------------+--------------------------+------------------------------------------------+
   | Оптимізація -О0        | Оптимізація -О2          | Оптимізація -О2 (global -> volatile)           |
   +------------------------+--------------------------+------------------------------------------------+
   | Результат              | Результат                | Результат                                      |
   +------------------------+--------------------------+------------------------------------------------+
   | 9955943                | 20000000                 | 11860273                                       |
   +------------------------+--------------------------+------------------------------------------------+
   | 12000504               | 20000000                 | 12000504                                       |
   +------------------------+--------------------------+------------------------------------------------+
   | 13142378               | 20000000                 | 13094729                                       |
   +------------------------+--------------------------+------------------------------------------------+
   | 13142378               | 20000000                 | 13461279                                       |
   +------------------------+--------------------------+------------------------------------------------+
   


Висновки
--------

Програма скомпільована з флагом -O2 при кожному запуску видає правильні результати за рахунок того, що код було оптимізовано. Замість того щоб
дійсно виконувати цикл та щоразу додавати 1, наш код додає до змінної число, що дорівнює ``steps``

Програма скомпільована з флагом -O0 при кожному запуску повертає неправильні результати. Це пов'язано з тим, що два потоки працюють конкурентно,
і оперують однаковими данними. 
В цій роботі я навчився працювати з MakeFile. Розібрався як руками проводити сборку в обьєктний файл та потім лінкувати.
Розібрався з флагами, як збирати, з форматом (в чому різниця між gnu18 та c18),також час був приділенний і рівням оптимізації, в нашому випадку це  ``O0`` та ``O2`` .
 При оптимізації ``O0`` результат не вірний по причині  порушення послідовності зчитування модифікування запису одного потоку іншим.
При оптимізації ``O2`` використовується лише в кінці під час виведення результату, і одказу записує до змінної результат інкрементації.
``volatile`` —  Модифікатор говорить про те, що ми будемо використовувати цю змінну різними потоками і вимагає від компілятора не розміщувати її для зберігання там, де ми не зможемо отримати до неї доступ.
 По суті в нас виникає "гонка даних", що нам і не дає отримати правильний результат.
``volatile``  ключове слово вказує на те, що значення може змінюватися між різними зверненнями, навіть якщо воно, здається, не модифікується. Це ключове слово 
заважає оптимізуючому компілятору оптимізувати подальші читання або записи і, таким чином, неправильно повторно використовує застаріле значення або пропускає записи.


Для того щоб програма виконувалась правильно необхідно використовувати наприклад: бар'єри пам'яті, спінлоки, м'ютекси тощо.
Частково запозичений матеріал у Харчука, було занадто гарно щоб не взяти.
