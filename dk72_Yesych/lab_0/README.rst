=================================================
**Лабораторна робота №0 Робота з потоками**
=================================================


Завдання
---------------
* Написати програму з наступним фунціоналом:
  Прогама повинна запускати два потоки які будуть конкурентно інрементувати одну змінну. 
* Проаналізувати отриманий результат при оптимізації ``O0`` та зрівняти його з очікуваним.
* Проаналізувати отриманий результат при оптимізації ``O2`` та зрівняти його з очікуваним.
* Додати модифікатор ``volatile`` до інкрементованої змінної та проаналізувати роботу програми.
* Написати MakeFile для зручної компіляції проекту

Хід роботи
------------------
**Написання програми**

В ході лабораторної роботи було написано програму що буде демонструвати конкуренту роботу двох потоків з однією змінною, а саме, ітерування цієї змінної.

За для зручносі під час перевіки роботи програми ініціалізацію змінної ітерування
було вирішено зробити наступним чином:

.. code-block:: C

 #if defined(VOLATILE) && VOLATILE
	 volatile unsigned long count;
 #else
	unsigned long count;
 #endif

Дана реалізація допомагає керувати модифікатором змінної за допомогою MakeFile ,тобто при визначенні VOLATILE в одиницю
змінна count  буде ініціалізована з модифікатором ``volatile``. Задання значення цієї змінної відбувається за допомогою агрументу 
командної строки  

.. code-block:: C

 count_type value = strtoul(argv[1], NULL, 10);

загальний вигляд функції ``main``:


.. code-block:: C

 int main(int argc, char *argv[])
 {
     pthread_t thread_id;

     if (argc != 2) {
         fprintf(stderr, "%s : wrong ammount of argumens : %d ; should be 1 \n",
			 argv[0], argc - 1);
         exit(1);
     }

     count_type value = strtoul(argv[1], NULL, 10);

     struct the_val pth_val = { .val = value };

     pthread_create(&thread_id, NULL, increment, &pth_val);

     for (int i = 0; i < value; i++)
         count++;

     pthread_join(thread_id, NULL);

     printf("expected = %ld; the resault = %ld \n", 2 * value, count);

     return 0;
 }



Для створення потоку було використано функцію ``pthread_create``. Приклад використання в прогамі:

.. code-block:: C

 pthread_create(&thread_id, NULL, increment, &pth_val);

* ``&thread_id``- вказівник на ідентифікатор потоку;
* ``increment``- вказівник на функцію що буде виконуватись в потоці;
* ``&pth_val``- вказівник на структуру що буде передаватись в якості аргументу;


Приєднання створеного потоку відбувається за допомогою функції ``pthread_join``. Приклад використання в прогамі:

.. code-block:: C

 pthread_join(thread_id, NULL);

* ``thread_id``- ідентифікатор потоку;

загальний вигляд функції ``increment``:

.. code-block:: C

 void *increment(void *val_str)
 {
     count_type value = ((struct the_val *)val_str)->val;

     for (int i = 0; i < value; i++)
         count++;
 }

**написання MakeFile**

За для зручності перевірки результату роботи програми було написано MakeFile 
зручність полягає в тому що є можливість визначити оптимізацію та модифікатор змінної без 
зайвого клопоту це відбувається за допомогою змінних: VOLAT, OPT_FLAG.
Також для зручності були написані цілі:

* all
* asm
* target

приклад використання: 

``
make OPT_FLAG=-O0 VOLAT=1 all
``

*
  .. list-table:: **Отримані результати**:
     :widths: auto
     :header-rows: 1

     * - Оптимізація -О0  
       - Оптимізація -О2 
       - Оптимізація -О2 (global -> volatile)
     * - 22139933
       - 20894247 
       - 21082661 
     * - 40000000
       - 40000000
       - 40000000
     * - 21410428
       - 21073774
       - 20645736
       
* 

Висновки
---------

в результаті роботи програми з різними прапорцями оптимізації ,а саме, ``O0`` та ``O2`` виникають різні результати роботи це можна помітити в вище 
зазначеній таблиці. При оплимізації ``O0`` результат не вірний по причині не атомарності виконуваних інструкцій, а саме, порушення послідовності
зчитування модифікування запису одного потоку іншим, пиклад на псевдокоді:

code block::

 read count thr1  (count = n)
 <---------------read count thr2 (count = n)
 count++ thr1 (count = n + 1)
 <---------------count++ thr2 (count = n + 1)
 write count thr1 (count = n + 1)
 <---------------write count thr2 (count = n + 1)

як результат у виподку такої послідовності виконання інструкцій після виконання інкременту обома потоками маємо збільшення змінної на 1 а 
не на 2(як повинно бути).
При оптимізації ``O2`` компілятор приймає до уваги що змінна ``count`` ніде не використовується 
під час інкременту, вона використовується лише в кінці під час виведення результату, і одказу записує до змінної результат інкрементації.
При використанні модифікатору ``volatile`` підчас ініціалізації змінної, компілятор не лптимізує змінну, тому і результат роботи програми такий самий
як і при оптимізації ``O0``.
                              